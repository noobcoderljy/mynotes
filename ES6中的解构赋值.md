# 数组的解构赋值
es6中允许按一定的模式，从数组或对象中提取值,对变量进行赋值,这被称为解构。  
```
let [a,b,c] =[1,2,3];

//等同于

let a=1;
let b=2;
let c=3;
```

### 模式匹配
等号两边的模式相同，那么左边的变量就会被赋予对应的值.
```
完全解构 左边模式对应右边
var [a,b,c] = [1,true,"aaa"]
//a = 1;
//b = true ;
//c = "aaa";

不完全解构 左边模式对应部分右边
var [a, ,b,d] = [1,true,"aaa"]
//a = 1;
//b = "aaa";
//d = undefined;
```

### 默认值
解构赋值允许使用默认值,当解构赋值的结果为undefined时,使用设置的默认值.
```
var [a = 1] = [undefined];
//a = 1;

var [b = 1] = [null]
// b = null
```
在es6中,使用严格相等运算符(===),所以null 不等于undefined.

默认值可以使用表达式,但这个表达式是惰性的,只有在使用时才会调用.
```
var [a = f()] = [1]

//等同于

let a;
if([1][0] === undefined){
    a = f();
}else{
    a = [1][0];
}
```

默认值可以使用其他变量,前提是已经声明.
```
let [a=1,b=a] =[]
// a=1 b=1

let[a=1,b=a]  = [2]
// a=2 b=2
let [a=b,b=1] =[]
// error
```

# 对象的解构赋值
对象的解构赋值通过与变量名相同的属性来赋值,没有次序.

```
let {b,a,c} = {a: 1,b: 2}
// a=1,b=2 c=undefined
```

对象解构赋值的内部机制,是先找到相同属性名,在在赋值给对应变量,也就是说实际被赋值的是foo:foo的后者,前者是匹配模式.
```
let {a,b} = {a:1,b:2}

//对象解构赋值是下面形式的简写

let {a:a,b:b} = {a:1,b:2}
a=1 b=2
```

### 默认值
对象的解构赋值也可以使用默认值,默认值生效的条件是对象的属性值严格等于undefined.
```
let {a:a=1,b:b=2} = {a:10,b:undefined}
//a = 10; b=2;
```
# 字符串解构赋值
字符串可以解构赋值,这是因为字符串被转化成一个类似于数组的对象.
```
let [a,b,c,d,e] = "hello"
//a="h" b="e" c="l" d="l" e="o"
```
# 数值和布尔值的解构赋值
在解构赋值时,如果右边是数字或布尔值,会先将其转化为对象.在解构赋值中,如果右边不是数组或者对象,就先转换为对象.而undefined和null无法转换,因此右边为undefined和null时会报错.
```
let {toString: a} = 123
// a = function toString
```

# 函数的解构赋值
函数也可以使用解构赋值,在传入参数时,构成解构.
```
function func([x,y]){
    return x+y;
}
func([1,2])
//3
```

函数参数使用默认值
为变量设置默认值
```
function func({a=10,b=10} = {}){
    return [a,b];
}
func({a:1,b:1}); //[1,1]
func({a:1}) //[1,10]
func({})//[10,10]
func() //[10,10]
```
为参数设定默认值
```
function func({a,b} = {a:10,b:10}){
    return[a,b]

}
func({a:1,b:1}) //[1.1]
func({a:1}) //[1,undefined]
func({}) //undefined indefined
func() // [10,10]
```
